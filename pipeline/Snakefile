configfile: 'snakemake.yaml'

DB_FILE = config["db_file"]
CLUSTER = ""
DIAMOND_PATH = config["diamond"]
RAXML_PATH = config["raxml"]
MUSCLE_PATH = config["muscle"]
HMMER_PATH = config["hmmer"]
MIN_IDENTITY = config["min_identity"]
CLUSTER_ALGO = config["clustering_algorithm"]
CLUSTER_SENSITIVITY = config["sensitivity"]
FAMILY_DB = config["family_db"]
FAMILY_PROFILE = FAMILY_DB.replace("seed", "hmm")
SAFETY_PATH = config["safety"]


# removes path and file extension from filename
def clean_filename(filename):
    return filename.split("/")[-1].split(".")[0]

DB_FILENAME = clean_filename(DB_FILE)
WORK_DIR = os.path.join("out", f"{DB_FILENAME}.{MIN_IDENTITY}.{CLUSTER_ALGO}")
CLUSTER_IDS, = glob_wildcards(os.path.join(WORK_DIR, "clean", "{id}.clean.fasta"))

def agg_input(wildcards):
    checkpoint_output = checkpoints.separate_clusters.get(**wildcards).output[1]
    CLUSTER_IDS, = glob_wildcards(os.path.join(checkpoint_output, "{id}.clean.fasta"))
    a = expand(os.path.join(WORK_DIR, "clean", "{i}.clean.fasta"), i=CLUSTER_IDS)
    return a
#Q09FY5
rule all:
    input:
        expand(os.path.join(WORK_DIR, "safety", "{id}.out"), id=CLUSTER_IDS),
        expand(os.path.join(WORK_DIR, "phmmer", "{id}.out"), id=CLUSTER_IDS),
        expand(os.path.join(WORK_DIR, "hmmsearch", "{id}.out"), id=CLUSTER_IDS),
        expand(os.path.join(WORK_DIR, "hmmscan", "{id}.out"), id=CLUSTER_IDS),
        # expand(os.path.join(WORK_DIR, "id", "{id}.out"), id=CLUSTER_IDS),

rule safe:
    input:
        expand(os.path.join(WORK_DIR, "safety", "{id}.out"), id=CLUSTER_IDS)

rule:
    input:
        fasta = os.path.join(WORK_DIR, "fasta", "{id}.fasta")
    output:
        os.path.join(WORK_DIR, "safety", "{id}.out")

    shell:
        "{SAFETY_PATH}/main -f {input.fasta} > {output}"

rule identity:
    input:
        expand(os.path.join(WORK_DIR, "id", "{id}.out"), id=CLUSTER_IDS)

rule:
    input:
        msa = os.path.join(WORK_DIR, "msa", "{id}.fasta")
    output:
        os.path.join(WORK_DIR, "id", "{id}.out")
    shell:
        "{HMMER_PATH}/bin/esl-alipid {input.msa} > {output}"

# search sequences agaianst a pfam domain database
rule hmmscan:
    input:
        expand(os.path.join(WORK_DIR, "hmmscan", "{id}.out"), id=CLUSTER_IDS)

rule:
    input:
        FAMILY_PROFILE + ".h3f",
        FAMILY_PROFILE + ".h3i",
        FAMILY_PROFILE + ".h3m",
        FAMILY_PROFILE + ".h3p",
        profile = FAMILY_PROFILE,
        fasta = os.path.join(WORK_DIR, "clean", "{id}.clean.fasta")
    output:
        os.path.join(WORK_DIR, "hmmscan", "{id}.out")
    shell:
        "{HMMER_PATH}/bin/hmmscan --tblout {output} --noali {input.profile} {input.fasta} > /dev/null"

# search sequences agaianst a pfam domain database
rule hmmscan_align:
    input:
        expand(os.path.join(WORK_DIR, "hmmscan_align", "{id}.out"), id=CLUSTER_IDS)

rule:
    input:
        FAMILY_PROFILE + ".h3f",
        FAMILY_PROFILE + ".h3i",
        FAMILY_PROFILE + ".h3m",
        FAMILY_PROFILE + ".h3p",
        profile = FAMILY_PROFILE,
        fasta = os.path.join(WORK_DIR, "clean", "{id}.clean.fasta")
    output:
        os.path.join(WORK_DIR, "hmmscan_align", "{id}.out")
    shell:
        "{HMMER_PATH}/bin/hmmscan -o {output} {input.profile} {input.fasta}"

rule:
    input:
        db = FAMILY_DB,
    output:
        profile = FAMILY_PROFILE
    shell:
        "{HMMER_PATH}/bin/hmmbuild {output.profile} {input.db}"

rule:
    input:
        profile = FAMILY_PROFILE
    output:
        FAMILY_PROFILE + ".h3f",
        FAMILY_PROFILE + ".h3i",
        FAMILY_PROFILE + ".h3m",
        FAMILY_PROFILE + ".h3p"
    shell:
        "{HMMER_PATH}/bin/hmmpress {input.profile}"

# phmmer for all clusters
rule phmmer:
    input:
        expand(os.path.join(WORK_DIR, "phmmer", "{id}.out"), id=CLUSTER_IDS)

rule:
    input:
        ref = os.path.join(WORK_DIR, "refs", "{id}.ref.fasta"),
        fasta = os.path.join(WORK_DIR, "clean", "{id}.clean.fasta"),
    output:
        os.path.join(WORK_DIR, "phmmer", "{id}.out")
    shell:
        "{HMMER_PATH}/bin/phmmer --tblout {output} --noali {input.ref} {input.fasta} > /dev/null"

# hmmsearch for all clusters
rule hmmsearch:
    input:
        expand(os.path.join(WORK_DIR, "hmmsearch", "{id}.out"), id=CLUSTER_IDS)

rule:
    input:
        fasta = os.path.join(WORK_DIR, "clean", "{id}.clean.fasta"),
        hmm = os.path.join(WORK_DIR, "profiles", "{id}.hmm")
    output:
        os.path.join(WORK_DIR, "hmmsearch", "{id}.out")
    shell:
        "{HMMER_PATH}/bin/hmmsearch --tblout {output} --noali {input.hmm} {input.fasta} > /dev/null"

# creates needed hmm-profiles for hmmsearch
rule hmmbuild:
    input:
        expand(os.path.join(WORK_DIR, "profiles", "{id}.hmm"), id=CLUSTER_IDS)

rule:
    input:
        os.path.join(WORK_DIR, "msa", "{id}.fasta")
    output:
        temp(os.path.join(WORK_DIR, "profiles", "{id}.hmm"))
    shell:
        "{HMMER_PATH}/bin/hmmbuild {output} {input}"

# MSA for all clusters with Muscle
rule msa:
    input:
        os.path.join(WORK_DIR, "info.txt"),
        expand(os.path.join(WORK_DIR, "msa", "{id}.fasta"), id=CLUSTER_IDS)
    run:
        # For some reason it runs general rule below only if we have some dummy code here???
        print("Done!")

rule:
    input:
        os.path.join(WORK_DIR, "clean", "{id}.clean.fasta")
    output:
        os.path.join(WORK_DIR, "msa", "{id}.fasta")
    shell:
        "{MUSCLE_PATH}/muscle3.8.31_i86darwin64 -in {input} -out {output}"

# Separates all clusters (that fit the threshold) into separate fasta-files
checkpoint separate_clusters:
    input:
        f"{DB_FILE}",
        os.path.join(WORK_DIR, f"{DB_FILENAME}.clusters")
    output:
        os.path.join(WORK_DIR, "info.txt"),
        directory(os.path.join(WORK_DIR, "clean")),
        directory(os.path.join(WORK_DIR, "fasta")),
        directory(os.path.join(WORK_DIR, "refs"))
    params:
        n = config["cluster_number"],
        min_size = config["cluster_min_size"],
        max_size = config["cluster_max_size"]
    shell:
        "python3 scripts/clusteread.py a {input} --n {params.n} --min {params.min_size} --max {params.max_size}"

# Generates diamond binary database for clustering
rule diamond_bin_db:
    input:
        f"{DB_FILE}"
    output:
        os.path.join("data", f"{DB_FILENAME}.dmnd")
    shell:
        "{DIAMOND_PATH}/bin/diamond makedb --in {input} -d {output}"

# Clustering
rule diamond_cluster:
    input:
        os.path.join("data", f"{DB_FILENAME}.dmnd")
    output:
        os.path.join(WORK_DIR, f"{DB_FILENAME}.clusters")
    params:
        identity=MIN_IDENTITY,
        algo=CLUSTER_ALGO,
        sens=CLUSTER_SENSITIVITY
    shell:
        "{DIAMOND_PATH}/bin/diamond cluster --cluster-algo {params.algo} --id {params.identity} {params.sens} -d {input} -o {output}"

# Prints some info about one cluster
rule cluster_info:
    input:
        f"{DB_FILE}",
        os.path.join(WORK_DIR, f"{DB_FILENAME}.clusters")
    params:
        cluster_name=CLUSTER
    shell:
        "python3 scripts/clusteread.py i {input}"

# Separates one cluster with id=CLUSTER
rule separate_cluster:
    input:
        f"{DB_FILE}",
        os.path.join(WORK_DIR, f"{DB_FILENAME}.clusters")
    output:
        os.path.join("out", f"{CLUSTER}.fasta"),
        os.path.join("out", f"{CLUSTER}.clean.fasta")
    params:
        cluster_name=CLUSTER
    shell:
        "python3 scripts/clusteread.py w {input} --id \"{params.cluster_name}\""

# MSA for one cluster
rule muscle:
    input:
        os.path.join("out", f"{CLUSTER}.clean.fasta")
    output:
        os.path.join("out", f"{CLUSTER}.msa.fasta")
    shell:
        "{MUSCLE_PATH}/muscle3.8.31_i86darwin64 -in \"{input}\" -out \"{output}\""

# Preprocessing for ML phylogenetic tree
rule raxml_check:
    input:
        os.path.join("out", f"{CLUSTER}.msa.fasta")
    output:
        os.path.join("out", f"{CLUSTER}.raxml.rba")
    params:
        cluster_name=CLUSTER
    shell:
        "{RAXML_PATH}/bin/raxml-ng --parse --msa \"{input}\" --model LG+G --prefix \"./out/{params.cluster_name}\""

# Builds ML phylogenetic tree
rule raxml:
    input:
        os.path.join("out", f"{CLUSTER}.raxml.rba")
    output:
        os.path.join("out", f"{CLUSTER}.raxml.bestTree")
    params:
        cluster_name=CLUSTER
    shell:
        "{RAXML_PATH}/bin/raxml-ng --msa \"{input}\" LG+G --prefix \"./out/{params.cluster_name}\""    

# Prints stats of the best phylogenetic tree
rule raxml_stats:
    input:
        os.path.join("out", f"{CLUSTER}.raxml.bestTree")
    shell:
        "python3 scripts/raxml_stats.py \"{input}\""

# Build taxonomic tree using taxonomic ids
# Searches for "OX=taxonomic_id", in fasta-file
rule taxtree:
    input:
        os.path.join("out", f"{CLUSTER}.fasta")
    output:
        os.path.join("out", f"{CLUSTER}.tax.tree")
    shell:
        "python3 scripts/taxtree.py \"{input}\""